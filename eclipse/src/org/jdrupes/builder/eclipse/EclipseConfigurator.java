/*
 * JDrupes Builder
 * Copyright (C) 2025 Michael N. Lipp
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package org.jdrupes.builder.eclipse;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.HashSet;
import java.util.Properties;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerFactoryConfigurationError;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.jdrupes.builder.api.BuildException;
import org.jdrupes.builder.api.FileTree;
import static org.jdrupes.builder.api.Intend.*;
import org.jdrupes.builder.api.MergedTestProject;
import org.jdrupes.builder.api.Project;
import org.jdrupes.builder.api.Resource;
import org.jdrupes.builder.api.ResourceRequest;
import org.jdrupes.builder.api.ResourceType;
import org.jdrupes.builder.core.AbstractGenerator;
import org.jdrupes.builder.core.DefaultFileTree;
import org.jdrupes.builder.java.ClasspathElement;
import org.jdrupes.builder.java.JavaCompiler;
import org.jdrupes.builder.java.JavaProject;
import org.jdrupes.builder.java.JavaResourceTree;
import static org.jdrupes.builder.java.JavaTypes.*;
import org.jdrupes.builder.java.LibraryJarFile;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;

/// The [EclipseConfigurator] provides the resource [EclipseConfiguration].
/// "The configuration" consists of the Eclipse configuration files
/// for a given project. The configurator generates the following
/// files as W3C DOM documents (for XML files) or as [Properties]
/// for a given project:
///
///   * `.project`,
///   * `.classpath`,
///   * `.settings/org.eclipse.core.resources.prefs`,
///   * `.settings/org.eclipse.core.runtime.prefs` and
///   * `.settings/org.eclipse.jdt.core.prefs`.
///
/// Each generated data structure can be post processed by a corresponding
/// `adapt` method before being written to disk. Additional resources can
/// be generated by the method [#adaptConfiguration].
///
/// Eclipse provides project nesting, but the outer project does not
/// define a namespace. This can lead to problems if you have multiple
/// (sub)projects with the same name in the workspace. The configurator
/// allows you to define an alias for the project name to avoid this
/// problem. This alias is used as Eclipse project name in all generated
/// files.
///
/// If a project is a [MergedTestProject], the configurator merges the
/// information from this test project into the configuration files of
/// its parent project. Resources that the test project depends
/// on will be added as "test only" class path resources and the folder
/// with the sources for the java compiler will be added as "test sources".
/// 
@SuppressWarnings("PMD.TooManyMethods")
public class EclipseConfigurator extends AbstractGenerator {

    /// The Constant GENERATED_BY.
    public static final String GENERATED_BY = "Generated by JDrupes Builder";
    private static DocumentBuilderFactory dbf
        = DocumentBuilderFactory.newInstance();
    private Supplier<String> eclipseAlias = () -> project().name();
    private BiConsumer<Document, Node> classpathAdaptor = (_, _) -> {
    };
    private Runnable configurationAdaptor = () -> {
    };
    private Consumer<Properties> jdtCorePrefsAdaptor = _ -> {
    };
    private Consumer<Properties> resourcesPrefsAdaptor = _ -> {
    };
    private Consumer<Properties> runtimePrefsAdaptor = _ -> {
    };
    private ProjectConfigurationAdaptor prjConfigAdaptor = (_, _, _) -> {
    };

    /// Instantiates a new eclipse configurator.
    ///
    /// @param project the project
    ///
    public EclipseConfigurator(Project project) {
        super(project);
    }

    /// Define the eclipse (alias) project name. 
    ///
    /// @param eclipseAlias the eclipse alias
    /// @return the eclipse configurator
    ///
    public EclipseConfigurator eclipseAlias(Supplier<String> eclipseAlias) {
        this.eclipseAlias = eclipseAlias;
        return this;
    }

    /// Define the eclipse (alias) project name. 
    ///
    /// @param eclipseAlias the eclipse alias
    /// @return the eclipse configurator
    ///
    public EclipseConfigurator eclipseAlias(String eclipseAlias) {
        this.eclipseAlias = () -> eclipseAlias;
        return this;
    }

    /// Returns the eclipse alias.
    ///
    /// @return the string
    ///
    public String eclipseAlias() {
        return eclipseAlias.get();
    }

    /// Provides an [EclipseConfiguration].
    ///
    /// @param <T> the generic type
    /// @param requested the requested
    /// @return the stream
    ///
    @Override
    protected <T extends Resource> Stream<T>
            doProvide(ResourceRequest<T> requested) {
        if (!requested.collects(new ResourceType<EclipseConfiguration>() {})) {
            return Stream.empty();
        }

        // Generate nothing for test projects.
        if (project() instanceof MergedTestProject) {
            return Stream.empty();
        }

        // Make sure that the directories exist.
        project().directory().resolve(".settings").toFile().mkdirs();

        // generate .project
        generateXmlFile(this::generateProjectConfiguration, ".project");

        // generate .classpath
        if (project() instanceof JavaProject) {
            generateXmlFile(this::generateClasspathConfiguration, ".classpath");
        }

        // Generate preferences
        generateResourcesPrefs();
        generateRuntimePrefs();
        if (project() instanceof JavaProject) {
            generateJdtCorePrefs();
        }

        // General overrides
        configurationAdaptor.run();

        // Create result
        @SuppressWarnings({ "unchecked", "PMD.UseDiamondOperator" })
        var result = (Stream<T>) Stream.of(project().newResource(
            new ResourceType<EclipseConfiguration>() {},
            project().name(), eclipseAlias()));
        return result;
    }

    private void generateXmlFile(Consumer<Document> generator, String name) {
        try {
            var doc = dbf.newDocumentBuilder().newDocument();
            generator.accept(doc);
            var transformer = TransformerFactory.newInstance().newTransformer();
            transformer.setOutputProperty(OutputKeys.INDENT, "yes");
            transformer.setOutputProperty(
                "{http://xml.apache.org/xslt}indent-amount", "4");
            try (var out = Files
                .newBufferedWriter(project().directory().resolve(name))) {
                transformer.transform(new DOMSource(doc),
                    new StreamResult(out));
            }
        } catch (ParserConfigurationException | TransformerException
                | TransformerFactoryConfigurationError | IOException e) {
            throw new BuildException(e);
        }
    }

    /// Generates the content of the `.project` file into the given document.
    ///
    /// @param doc the document
    ///
    @SuppressWarnings("PMD.AvoidDuplicateLiterals")
    protected void generateProjectConfiguration(Document doc) {
        var prjDescr = doc.appendChild(doc.createElement("projectDescription"));
        prjDescr.appendChild(doc.createElement("name"))
            .appendChild(doc.createTextNode(eclipseAlias()));
        prjDescr.appendChild(doc.createElement("comment")).appendChild(
            doc.createTextNode(GENERATED_BY));
        prjDescr.appendChild(doc.createElement("projects"));
        var buildSpec = prjDescr.appendChild(doc.createElement("buildSpec"));
        var natures = prjDescr.appendChild(doc.createElement("natures"));
        if (project() instanceof JavaProject) {
            var cmd = buildSpec.appendChild(doc.createElement("buildCommand"));
            cmd.appendChild(doc.createElement("name")).appendChild(
                doc.createTextNode("org.eclipse.jdt.core.javabuilder"));
            cmd.appendChild(doc.createElement("arguments"));
            natures.appendChild(doc.createElement("nature")).appendChild(
                doc.createTextNode("org.eclipse.jdt.core.javanature"));
        }

        // Allow derived class to adapt the project configuration
        prjConfigAdaptor.accept(doc, buildSpec, natures);
    }

    /// Allow derived classes to post process the project configuration.
    ///
    @FunctionalInterface
    public interface ProjectConfigurationAdaptor {
        /// Execute the adaptor.
        ///
        /// @param doc the document
        /// @param buildSpec shortcut to the `buildSpec` element
        /// @param natures shortcut to the `natures` element
        ///
        void accept(Document doc, Node buildSpec,
                Node natures);
    }

    /// Adapt project configuration.
    ///
    /// @param adaptor the adaptor
    /// @return the eclipse configurator
    ///
    public EclipseConfigurator adaptProjectConfiguration(
            ProjectConfigurationAdaptor adaptor) {
        prjConfigAdaptor = adaptor;
        return this;
    }

    /// Generates the content of the `.classpath` file into the given
    /// document.
    ///
    /// @param doc the doc
    ///
    @SuppressWarnings({ "PMD.AvoidDuplicateLiterals" })
    protected void generateClasspathConfiguration(Document doc) {
        var classpath = doc.appendChild(doc.createElement("classpath"));
        addCompilationResources(doc, classpath, project());
        addJavaResources(doc, classpath, project());

        // Add projects
        final Set<ClasspathElement> suppliedByProject = new HashSet<>();
        final Set<Project> contributing = new HashSet<>();
        collectContributing(contributing, project());
        contributing.remove(project());
        contributing.stream().forEach(p -> {
            if (p instanceof MergedTestProject) {
                if (p.parentProject().get().equals(project())) {
                    // Test projects contribute their resources to the parent
                    addCompilationResources(doc, classpath, p);
                    addJavaResources(doc, classpath, p);
                }
                return;
            }
            var entry = (Element) classpath
                .appendChild(doc.createElement("classpathentry"));
            entry.setAttribute("kind", "src");
            var referenced = p.get(requestFor(EclipseConfiguration.class))
                .filter(c -> c.projectName().equals(p.name())).findFirst()
                .map(EclipseConfiguration::eclipseAlias).orElse(p.name());
            entry.setAttribute("path", "/" + referenced);
            var attributes = entry.appendChild(doc.createElement("attributes"));
            var attribute = (Element) attributes
                .appendChild(doc.createElement("attribute"));
            attribute.setAttribute("without_test_code", "true");
            suppliedByProject.addAll(p.from(Supply)
                .get(requestFor(ClasspathElement.class)).toList());
        });

        // Add jars
        final Set<ClasspathElement> exposedByProject = new HashSet<>();
        exposedByProject.addAll(project().from(Expose)
            .get(requestFor(ClasspathElement.class)).toList());
        project().provided(requestFor(JarLibrariesType))
            .filter(jf -> !suppliedByProject.contains(jf))
            .collect(Collectors.toSet()).stream().forEach(jf -> {
                addJarFileEntry(doc, classpath, jf,
                    exposedByProject.contains(jf), false);
            });

        // Allow derived class to override
        classpathAdaptor.accept(doc, classpath);
    }

    @SuppressWarnings("PMD.AvoidDuplicateLiterals")
    private void addJarFileEntry(Document doc, Node classpath,
            LibraryJarFile jarFile, boolean exported, boolean test) {
        var entry = (Element) classpath
            .appendChild(doc.createElement("classpathentry"));
        entry.setAttribute("kind", "lib");
        var jarPathName = jarFile.path().toString();
        entry.setAttribute("path", jarPathName);
        if (exported) {
            entry.setAttribute("exported", "true");
        }
        if (test) {
            var attr = (Element) entry
                .appendChild(doc.createElement("attributes"))
                .appendChild(doc.createElement("attribute"));
            attr.setAttribute("name", "test");
            attr.setAttribute("value", "true");
        }

        // Educated guesses
        var sourcesJar
            = new File(jarPathName.replaceFirst("\\.jar$", "-sources.jar"));
        if (sourcesJar.canRead()) {
            entry.setAttribute("sourcepath", sourcesJar.getAbsolutePath());
        }
        var javadocJar = new File(
            jarPathName.replaceFirst("\\.jar$", "-javadoc.jar"));
        if (javadocJar.canRead()) {
            var attr = (Element) entry
                .appendChild(doc.createElement("attributes"))
                .appendChild(doc.createElement("attribute"));
            attr.setAttribute("name", "javadoc_location");
            attr.setAttribute("value",
                "jar:file:" + javadocJar.getAbsolutePath() + "!/");
        }
    }

    private void addJavaResources(Document doc, Node classpath,
            Project project) {
        // TODO Generalize. Currently we assume a Java compiler exists
        // and use it to obtain the output directory for all generators
        var javaCompiler = project.providers(Supply, Consume)
            .filter(p -> p instanceof JavaCompiler)
            .map(JavaCompiler.class::cast).findFirst();
        var outputDirectory
            = javaCompiler.map(jc -> project.relativize(jc.destination()));

        // Add resources
        project.from(Supply, Consume).without(Project.class)
            .get(requestFor(JavaResourceTree.class)).map(DefaultFileTree::root)
            .filter(p -> p.toFile().canRead()).map(project::relativize)
            .forEach(p -> {
                var entry = (Element) classpath
                    .appendChild(doc.createElement("classpathentry"));
                entry.appendChild(doc.createComment("From " + project));
                entry.setAttribute("kind", "src");
                entry.setAttribute("path", p.toString());
                if (project instanceof MergedTestProject) {
                    outputDirectory.ifPresent(o -> {
                        entry.setAttribute("output", o.toString());
                    });
                    var attr = (Element) entry
                        .appendChild(doc.createElement("attributes"))
                        .appendChild(doc.createElement("attribute"));
                    attr.setAttribute("name", "test");
                    attr.setAttribute("value", "true");
                }
            });
    }

    private void addCompilationResources(Document doc, Node classpath,
            Project project) {
        // TODO Generalize. Currently we assume a Java compiler exists
        // and use it to obtain the output directory for all generators
        var javaCompiler = project.providers(Supply, Consume)
            .filter(p -> p instanceof JavaCompiler)
            .map(JavaCompiler.class::cast).findFirst();
        var outputDirectory
            = javaCompiler.map(jc -> project.relativize(jc.destination()));

        // Add source trees
        project.from(Supply, Consume).without(Project.class)
            .get(requestFor(JavaSourceTreesType)).map(FileTree::root)
            .filter(p -> p.toFile().canRead()).map(project::relativize)
            .forEach(p -> {
                var entry = (Element) classpath
                    .appendChild(doc.createElement("classpathentry"));
                entry.appendChild(doc.createComment("From " + project));
                entry.setAttribute("kind", "src");
                entry.setAttribute("path", p.toString());
                if (project instanceof MergedTestProject) {
                    outputDirectory.ifPresent(o -> {
                        entry.setAttribute("output", o.toString());
                    });
                    var attr = (Element) entry
                        .appendChild(doc.createElement("attributes"))
                        .appendChild(doc.createElement("attribute"));
                    attr.setAttribute("name", "test");
                    attr.setAttribute("value", "true");
                }
            });

        // For merged test project also add compile path resources
        if (project instanceof MergedTestProject) {
            var from = project.from(Consume, Expose)
                .without(project.parentProject().get());
            javaCompiler.ifPresent(from::without);
            from.get(requestFor(JarLibrariesType)).forEach(jf -> {
                addJarFileEntry(doc, classpath, jf, false, true);
            });
            return;
        }

        // For "normal projects" configure default output directory
        outputDirectory.ifPresent(o -> {
            var entry = (Element) classpath
                .appendChild(doc.createElement("classpathentry"));
            entry.setAttribute("kind", "output");
            entry.setAttribute("path", o.toString());
        });

        // Finally Add JRE
        javaCompiler.ifPresent(jc -> {
            jc.optionArgument("-target", "--target", "--release")
                .ifPresentOrElse(v -> addSpecificJre(doc, classpath, v),
                    () -> addInheritedJre(doc, classpath));
        });
    }

    private void collectContributing(Set<Project> collected, Project project) {
        if (collected.contains(project)) {
            return;
        }
        collected.add(project);
        project.providers(Consume, Forward, Expose)
            .filter(p -> p instanceof Project).map(p -> (Project) p)
            .forEach(p -> collectContributing(collected, p));
    }

    private void addSpecificJre(Document doc, Node classpath,
            String version) {
        var entry = (Element) classpath
            .appendChild(doc.createElement("classpathentry"));
        entry.setAttribute("kind", "con");
        entry.setAttribute("path",
            "org.eclipse.jdt.launching.JRE_CONTAINER"
                + "/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType"
                + "/JavaSE-" + version);
        var attributes = entry.appendChild(doc.createElement("attributes"));
        var attribute
            = (Element) attributes.appendChild(doc.createElement("attribute"));
        attribute.setAttribute("name", "module");
        attribute.setAttribute("value", "true");
    }

    private void addInheritedJre(Document doc, Node classpath) {
        var entry = (Element) classpath
            .appendChild(doc.createElement("classpathentry"));
        entry.setAttribute("kind", "con");
        entry.setAttribute("path",
            "org.eclipse.jdt.launching.JRE_CONTAINER");
        var attributes = entry.appendChild(doc.createElement("attributes"));
        var attribute
            = (Element) attributes.appendChild(doc.createElement("attribute"));
        attribute.setAttribute("name", "module");
        attribute.setAttribute("value", "true");
    }

    /// Allow the user to post process the classpath configuration.
    /// The node passed to the consumer is the `classpath` element.
    ///
    /// @param adaptor the adaptor
    /// @return the eclipse configurator
    ///
    public EclipseConfigurator
            adaptClasspathConfiguration(BiConsumer<Document, Node> adaptor) {
        classpathAdaptor = adaptor;
        return this;
    }

    /// Generate the properties for the
    /// `.settings/org.eclipse.core.resources.prefs` file.
    ///
    @SuppressWarnings("PMD.PreserveStackTrace")
    protected void generateResourcesPrefs() {
        var props = new Properties();
        props.setProperty("eclipse.preferences.version", "1");
        props.setProperty("encoding/<project>", "UTF-8");
        resourcesPrefsAdaptor.accept(props);
        try (var out = new FixCommentsFilter(Files.newBufferedWriter(
            project().directory().resolve(
                ".settings/org.eclipse.core.resources.prefs")),
            GENERATED_BY)) {
            props.store(out, "");
        } catch (IOException e) {
            throw new BuildException(
                "Cannot write eclipse settings: " + e.getMessage());
        }
    }

    /// Allow the user to adapt the properties for the
    /// `.settings/org.eclipse.core.resources.prefs` file.
    ///
    /// @param adaptor the adaptor
    /// @return the eclipse configurator
    ///
    public EclipseConfigurator
            adaptResourcePrefs(Consumer<Properties> adaptor) {
        resourcesPrefsAdaptor = adaptor;
        return this;
    }

    /// Generate the properties for the
    /// `.settings/org.eclipse.core.runtime.prefs` file.
    ///
    @SuppressWarnings("PMD.PreserveStackTrace")
    protected void generateRuntimePrefs() {
        var props = new Properties();
        props.setProperty("eclipse.preferences.version", "1");
        props.setProperty("line.separator", "\n");
        runtimePrefsAdaptor.accept(props);
        try (var out = new FixCommentsFilter(Files.newBufferedWriter(
            project().directory().resolve(
                ".settings/org.eclipse.core.runtime.prefs")),
            GENERATED_BY)) {
            props.store(out, "");
        } catch (IOException e) {
            throw new BuildException(
                "Cannot write eclipse settings: " + e.getMessage());
        }
    }

    /// Allow the user to adapt the properties for the
    /// `.settings/org.eclipse.core.runtime.prefs` file.
    ///
    /// @param adaptor the adaptor
    /// @return the eclipse configurator
    ///
    public EclipseConfigurator adaptRuntimePrefs(Consumer<Properties> adaptor) {
        runtimePrefsAdaptor = adaptor;
        return this;
    }

    /// Generate the properties for the
    /// `.settings/org.eclipse.jdt.core.prefs` file.
    ///
    @SuppressWarnings("PMD.PreserveStackTrace")
    protected void generateJdtCorePrefs() {
        var props = new Properties();
        props.setProperty("eclipse.preferences.version", "1");
        project().providers(Supply)
            .filter(p -> p instanceof JavaCompiler).map(p -> (JavaCompiler) p)
            .findFirst().ifPresent(jc -> {
                jc.optionArgument("-target", "--target", "--release")
                    .ifPresent(v -> {
                        props.setProperty("org.eclipse.jdt.core.compiler"
                            + ".codegen.targetPlatform", v);
                    });
                jc.optionArgument("-source", "--source", "--release")
                    .ifPresent(v -> {
                        props.setProperty("org.eclipse.jdt.core.compiler"
                            + ".source", v);
                        props.setProperty("org.eclipse.jdt.core.compiler"
                            + ".compliance", v);
                    });
            });
        jdtCorePrefsAdaptor.accept(props);
        try (var out = new FixCommentsFilter(Files.newBufferedWriter(
            project().directory()
                .resolve(".settings/org.eclipse.jdt.core.prefs")),
            GENERATED_BY)) {
            props.store(out, "");
        } catch (IOException e) {
            throw new BuildException(
                "Cannot write eclipse settings: " + e.getMessage());
        }
    }

    /// Allow the user to adapt the properties for the
    /// `.settings/org.eclipse.jdt.core.prefs` file.
    ///
    /// @param adaptor the adaptor
    /// @return the eclipse configurator
    ///
    public EclipseConfigurator adaptJdtCorePrefs(Consumer<Properties> adaptor) {
        jdtCorePrefsAdaptor = adaptor;
        return this;
    }

    /// Allow the user to add additional resources.
    ///
    /// @param adaptor the adaptor
    /// @return the eclipse configurator
    ///
    public EclipseConfigurator adaptConfiguration(Runnable adaptor) {
        configurationAdaptor = adaptor;
        return this;
    }

}
